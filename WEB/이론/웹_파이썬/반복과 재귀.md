#### 반복을 이용한 선택정렬

#### 재귀적 알고리즘
* 재귀적 정의는 두 부분으로 나뉜다.

타이핑 시간없으니 눈 공부 ㄱ

```python
# recur 2
def f(i, N, key, arr):
    if i == N:
        return
    elif arr[i] == key:
        return 1
    else:
        f(i+1, N, key, arr)

N = 5
A = [1,2,3,4,5]
key = 3
f(0, N, key, arr)
```

```python
# perm 1
def f(i, N, K):
    if i == N:
        return
    else:
        for j in range(N):
            if used[j] == 0:
                p[i] = card[j]
                used[j] = 1
                f(i+1, N, K)
                used[j] = 0

card = list(map(int,input()))
N = 5
K = 3
used = [0] * 6
p = [0] * 6
cnt = 0
f(0, N, K)
```

### 부분 집합
#### 집합에 포함된 원소들을 선택하는 것이다.
#### 다수의 중요 알고리즘들이 원소의 그룹에서 최적의 부분 집합을 찾는 것이다.
#### N개의 원소를 포함한 집합
* 자기 자신과 공집합을 포함한 모든 부분집합의 개수는 2^n개
* 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가

# 현강

```python
def recur(depth, N, nums, used):
    """
    :param depth: 재귀호출을 몇번 진행했는지 (카운트값)
    :param nums: 1~3 까지의 원소를 담는 리스트
    :return: 없음
    """
    # 기저조건 (종료조건)
    if depth == N:
        # 요소의 값을 출력한다...
        # for i in nums:
        #     print(i, end='-')
        print("-".join([str(num) for num in nums]))
        return
    # 유도조건 (재귀호출)
    # i : 1 -> 3
    for i in range(1, 4):
        if used[i] == False:  # 사용했는지 여부 체크
            nums.append(i)  # 결정
            used[i] = True  # 사용했음을 체크
            recur(depth + 1, N, nums, used)
            nums.pop()  # 복구
            used[i] = False  # 복구


N = 3
recur(0, N, [], [False] * (N + 1))
```

```python
# nPk : n개의 값에서 k를 선택해 뽑으세요. 순열 (재귀)
def P(arr, n, k, used, picks, depth):
    """
    :param arr: 뽑고자 하는 배열 (요소의 갯수는 n개)
    :param n: 배열의 길이
    :param k: 뽑고자 하는 요소의 갯수
    :return: 없음
    """
    # 기저조건
    if depth == k:  # K 만큼 뽑았다면 정지..
        # 내가 지금까지 뽑은 값을 출력
        print(picks)
        return
    # 유도조건 (재귀)
    # 모든 배열 요소값에 대해서 순회 (인덱스 순회)
    for i in range(n):
        # 사용여부
        if used[i] == False:  # 사용하지 않은 수라면..
            # 결정 : 사용(사용을 했다 체크)
            used[i] = True
            picks.append(arr[i])  # 해당 숫자를 픽에 추가.
            P(arr, n, k, used, picks, depth + 1)  # 재귀 호출
            # 복구
            used[i] = False
            picks.pop()


arr = [1, 3, 5, 7, 9, 10]
N = 6  # len(arr)
used = [False] * (N)  # 사용한 값을 표기
picks = []  # 내가 뽑을 k개의 값을 담을 리스트

P(arr, N, 3, used, picks, 0)  # 6P3 경우의 수를 모두 출력해봐라...
```

```python
# nPk : n개의 값에서 k를 선택해 뽑으세요. 순열 (재귀)
def P(arr, n, k, depth):
    # 기저조건
    if depth == k:
        # 만들어진 순열을 출력한다...
        # for i in range(k):
        #     print(arr[i], end=' ')
        # print()
        print(arr[:k])
        return

    # 유도조건
    s = depth
    for e in range(s, n):
        # s <-> e 스왑 (결정)
        arr[s], arr[e] = arr[e], arr[s]
        # 재귀호출
        P(arr, n, k, depth + 1)
        # s <-> e 스왑 (복구)
        arr[s], arr[e] = arr[e], arr[s]


arr = [1, 3, 5, 7, 9, 10]
N = 6  # len(arr)

P(arr, N, 3, 0)  # 6P3 경우의 수를 모두 출력해봐라...
```

```python
T = int(input())  # 테스트케이스
for tc in range(1, T + 1):
    # arr: 카드 6개를 리스트로 저장
    arr = list(map(int, list(input())))  # "123456" -> [1, 2, 3, 4, 5, 6]

    # 로직
    # 조합을 저장할 수 있는 배열 (카드 6자리 조합을 임시 저장)
    cards = [0] * 6
    # 만들 수 있는 baby-gin 조합을 만든다.
    # 카드의 값이 0 ~ 9...
    # run 조건 : 3장의 카드가 모두 같은 값...
    # triplet 조건 : 3장의 카드가 연달아서 값을 가지고 있으면...

    # run - run 6장
    for i in range(0, 10):
        cards[0] = cards[1] = cards[2] = i
        for j in range(0, 10):
            cards[3] = cards[4] = cards[5] = j
            # <- 이 부분에서 순열 가짓수를 만들어서 테스트 (6P6)

    # run - tri 6장
    for i in range(0, 10):
        cards[0] = cards[1] = cards[2] = i
        for j in range(0, 8):
            cards[3] = j
            cards[4] = j + 1
            cards[5] = j + 2
            # <- 이 부분에서 순열 가짓수를 만들어서 테스트 (6P6)

    # tri - tri 6장
    for i in range(0, 8):
        cards[0] = i
        cards[1] = i + 1
        cards[2] = i + 2
        for j in range(0, 8):
            cards[3] = j
            cards[4] = j + 1
            cards[5] = j + 2
            # <- 이 부분에서 순열 가짓수를 만들어서 테스트 (6P6)

    # 출력
    # 베이비진이 완성된 케이스와 동일한 값을 같는다면 true를 출력, (아니라면 false를 출력)
    # print...
```